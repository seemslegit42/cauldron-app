# **Comprehensive Overview of the OpenSaaS WASP Boilerplate for AI Coding Agents**

## **1\. Introduction to OpenSaaS and the WASP Framework**

OpenSaaS presents itself as a robust and accessible solution for developers seeking to build Software-as-a-Service (SaaS) applications efficiently.1 This boilerplate is fully open-source and free for anyone to use and distribute, fostering a community-driven environment that encourages continuous improvement.1 Its primary aim is to equip developers, including indiehackers and solopreneurs, with all the essential features needed to launch a SaaS product rapidly.2 The success of applications like PromptPanda, a prompt library SaaS, and Meeting Reminders, a Google Workspace add-on, which were built using OpenSaaS, underscores its versatility and ease of application across different SaaS domains.4 The underlying philosophy emphasizes community contribution and the democratization of SaaS development by providing a feature-rich template that lowers the barrier to entry.3

At the core of OpenSaaS lies the WASP (Web Application Specification) framework, a full-stack framework that leverages the power of React for the frontend, Node.js for the backend, and Prisma for database management.1 WASP is designed as a "Rails-like framework for React, Node.js, and Prisma," streamlining the development process and enabling deployment with a single command-line instruction.7 A key aspect of WASP is its ability to manage the often tedious boilerplate code associated with modern web development, allowing developers to concentrate on the unique aspects of their application's business logic.6 This is achieved through a central configuration file, main.wasp, which acts as the single source of truth for the application's architecture, and a powerful compiler that generates the necessary code based on this configuration.7 WASP's feature set includes comprehensive full-stack authentication, end-to-end type safety, the ability to define and run background jobs, and simplified deployment procedures, making it a powerful tool for building modern web applications.1

## **2\. Key Features and Components of the OpenSaaS WASP Boilerplate**

OpenSaaS comes equipped with a wide array of features designed to accelerate SaaS development.1 These out-of-the-box functionalities include robust authentication mechanisms supporting email, Google, and GitHub logins. For monetization, the boilerplate offers seamless integration with popular payment processors like Stripe and Lemon Squeezy. Analytics are also a core component, with support for both Plausible and Google Analytics, providing insights into user behavior and application performance. Furthermore, an administrative dashboard is included, offering a centralized interface for managing users and viewing key metrics.1 The template also provides practical examples of integrating with external services such as the OpenAI API for AI-powered features, AWS S3 for efficient file storage and retrieval, and various email sending services to handle transactional and marketing communications.2 The flexibility of OpenSaaS allows developers to tailor the boilerplate to their specific needs by easily removing any features that are not required and customizing various aspects like content sections, the application logo, and the main hero banner.9 This pre-built suite of features ensures that developers can hit the ground running, focusing on their core product differentiation rather than spending time on foundational elements common to most SaaS applications.

The main.wasp file serves as the central configuration hub for any application built with the WASP framework, including those using the OpenSaaS template.6 It operates as the "central nervous system," providing a declarative way to define all the essential aspects of the application.6 Within this file, the app declaration sets the global configurations for the application, such as its title, which appears in the browser tab, and allows for the inclusion of configurations for the \<head\> section of the HTML, where analytics scripts can be added.9 Routing within the application is defined through route declarations, which map specific URL paths to corresponding page components.11 The page declarations then specify the React component that should be rendered when a particular route is accessed.11 For defining the application's data structure, entity declarations are used. These leverage Prisma Schema Language (PSL) within special tags {=psl... psl=} to model database tables and their fields.13 To handle data fetching and manipulation, query and action declarations define API endpoints, linking to their respective implementations located in the src/server directory.6 Background tasks, such as scheduled analytics updates, are configured using job declarations, which include details about their execution schedule.9 Finally, for more advanced use cases, api declarations allow for the definition of custom HTTP API endpoints.9 The following table summarizes the key declaration types found in the main.wasp file:

| Declaration Type | Purpose | Key Attributes/Configurations | Snippet References |
| :---- | :---- | :---- | :---- |
| app | Defines global application settings | title, wasp version, head | 9 |
| route | Maps URL paths to pages | path, to (page component) | 11 |
| page | Specifies the React component to render for a route | component (import path), authRequired | 11 |
| entity | Defines the data model (database schema) using Prisma Schema Language (PSL) | Fields, data types, Prisma directives (@id, @default, @unique), relationships | 13 |
| query | Defines a read operation (data fetching) | fn (import path to implementation), entities (list of entities used) | 6 |
| action | Defines a write operation (data manipulation) | fn (import path to implementation), entities (list of entities used) | 6 |
| job | Configures background tasks | executor, perform (fn import), schedule (cron expression) | 9 |
| api | Defines custom HTTP API endpoints | fn (import path to handler), httpRoute (method and path), entities (list of entities) | 9 |

The schema.prisma file, located at the root of the project, is where the application's database schema is defined using Prisma Schema Language (PSL).7 This file contains model definitions, each representing a table in the database and outlining its various fields along with their data types and any constraints.7 Within the WASP framework, these models are referred to as "Entities".7 WASP's compiler processes this file to understand the application's data structure, automatically generating corresponding code, including type definitions that can be used within the application's TypeScript code via the wasp/entities import.20 Relationships between different data models, such as one-to-many or many-to-many associations, are defined within schema.prisma using the @relation directive.20 Any modifications made to the schema.prisma file necessitate running the command wasp db migrate-dev in the terminal. This command generates and applies SQL migrations to update the database schema based on the changes made in the PSL.20 This ensures that the application's data model remains synchronized with the underlying database structure.

## **3\. Architectural Patterns and Project Structure in WASP**

The WASP framework employs a compiler-based architecture where the core component, the Wasp compiler, written in Haskell, plays a pivotal role in the application development process.14 This compiler analyzes the main.wasp configuration file alongside the custom code written by the developer in the src/ directory, which typically includes React components for the frontend and Node.js logic for the backend.6 Based on this analysis, the Wasp compiler intelligently generates the complete source code for the web application, encompassing the frontend, backend, and even deployment configurations.6 This code generation process includes setting up the necessary connections to the server and database, establishing communication pathways between the client and server with built-in type safety, managing complex authentication workflows, and simplifying the often intricate process of deployment.6 Notably, the code generated by the Wasp compiler is designed to be human-readable and can be inspected by developers within the .wasp/ directory located in the project.8 This architectural approach allows developers to define their application at a high level using the Wasp DSL and then rely on the compiler to handle the underlying infrastructure, enabling them to focus primarily on implementing their application's unique business logic.

A standard WASP project, particularly one generated from the OpenSaaS template, follows a well-defined structure that promotes organization and maintainability.18 The .wasp/ directory is where the Wasp compiler outputs the generated code, which forms the foundation of the application.8 The src/ directory is where developers write their custom application logic, separated into client for React components and server for Node.js backend code.18 Within src/, it is common practice to further organize the code by feature, with each feature residing in its own subdirectory (e.g., src/features/auth, src/features/transactions).18 The public/ directory is designated for storing static assets such as images and the application's favicon.11 The schema.prisma file, located at the project root, contains the definition of the database schema using Prisma Schema Language.11 Also at the root level is the crucial main.wasp file, which serves as the central configuration for the entire application.11 Project dependencies and management scripts are defined in package.json and package-lock.json.9 Other configuration files such as tsconfig.json for TypeScript settings, vite.config.ts for the Vite build tool configuration, .gitignore to specify files to be ignored by Git, and .waspignore for files to be ignored by the Wasp compiler, are also typically found at the root.9 In OpenSaaS projects, a blog/ directory might also be present, housing the Astro Starlight template used for the blog and documentation sections of the application.9 This clear separation of concerns within the project structure helps developers, and by extension AI coding agents, to easily navigate and understand the different parts of the application.

WASP strongly advocates for a modular approach to application development, encouraging developers to organize their code based on features.24 This typically involves creating subdirectories within the src/features/ directory, where each subdirectory corresponds to a specific feature of the application (e.g., authentication, user profiles, payment processing).24 To maintain organization within the main.wasp configuration file, WASP provides a convention of using //\#region {FeatureName} and //\#endregion comments to group related configurations such as routes, pages, and operations that pertain to a particular feature.25 Furthermore, it is a common practice to consolidate the implementations of WASP operations (both queries and actions) related to a specific feature into a single file named operations.ts (or operations.js if using JavaScript) located within the feature's directory (e.g., src/features/transactions/operations.ts).25 These principles of feature-based organization and the use of logical groupings within both the file system and the central configuration file contribute significantly to the overall modularity and maintainability of WASP applications, making it easier to manage and extend the codebase as the application grows in complexity.

## **4\. Coding Conventions and Best Practices for WASP Development**

When developing with the WASP framework, particularly within the context of the OpenSaaS boilerplate, adherence to certain coding conventions and best practices is crucial for ensuring code quality, maintainability, and collaboration. For source code files within the src/ directory, the use of .js, .jsx, .ts, or .tsx extensions is standard.9 Given WASP's strong support for TypeScript, which provides static typing benefits for both client-side and server-side code, the use of .ts or .tsx is highly recommended.1 Organizing the code within src/ by feature into logical subdirectories (e.g., auth, dashboard, transactions) is a widely adopted practice.18 Operation implementations, whether they are queries for data retrieval or actions for data manipulation, are typically grouped into an operations.ts (or .js) file within the corresponding feature directory.25 React components responsible for rendering the user interface are generally placed in the src/client directory or within feature-specific subdirectories under src/features, while reusable UI elements are often located in a dedicated src/components directory.18

While specific detailed code formatting rules are not explicitly provided in the research material, it is generally expected that developers will follow standard JavaScript and TypeScript formatting practices. Utilizing a code formatter such as Prettier is highly recommended to ensure consistency across the codebase. For styling the frontend, the OpenSaaS boilerplate leverages TailwindCSS, a utility-first CSS framework.1 This implies that developers should be familiar with Tailwind's approach of applying styles directly to HTML elements using predefined utility classes. The configuration for TailwindCSS is typically found in the tailwind.config.cjs file at the project root.9

When working with the central main.wasp configuration file, several best practices should be followed.19 All core aspects of the application, including app settings, routes, pages, authentication configurations, database entities, queries, actions, background jobs, and custom APIs, should be declared within this file. When importing custom code, such as React component implementations or the functions implementing queries and actions, it is crucial to always use the @src/ prefix in the import paths.11 This convention helps WASP correctly resolve the file paths and avoids issues that can arise with relative imports (e.g., ../src/...).25 For each query or action defined in main.wasp, all the database Entities that are accessed or manipulated within its implementation must be explicitly listed in the entities: \[...\] declaration.20 To maintain clarity and organization in main.wasp, especially in larger applications with many features, it is highly recommended to group related declarations together using //\#region {FeatureName} and //\#endregion comment directives.25

Given WASP's native and robust support for TypeScript, adopting it throughout the project is a significant best practice that enhances code quality and maintainability.1 TypeScript can be seamlessly used for both the frontend React components and the backend Node.js logic.14 A key advantage of using TypeScript with WASP is the automatic generation of type definitions for database Entities and the application's Operations (Queries and Actions).20 These generated types can be imported into the TypeScript code to provide compile-time type checking, improving code safety and developer experience. Entity types are typically imported from wasp/entities, while operation types are imported from either wasp/server/operations for backend implementations or wasp/client/operations for frontend calls.25

Finally, for managing project dependencies, the recommended best practice is to avoid directly adding dependencies to the main.wasp configuration file.25 Instead, developers should use standard JavaScript package managers like npm or yarn to install any required libraries or packages. This is done via the command line using npm install \<package-name\> or yarn add \<package-name\>, which automatically updates the package.json file and the lock file (package-lock.json or yarn.lock) to reflect the changes.25 This approach ensures that dependencies are managed consistently and according to the established practices of the JavaScript ecosystem.

## **5\. Core Technologies and their Integration**

The OpenSaaS WASP boilerplate is built upon a foundation of several key technologies that work together to provide a comprehensive full-stack development experience. React serves as the primary library for constructing the dynamic and interactive user interface on the frontend.1 WASP's architecture is designed to seamlessly integrate with React, generating the necessary infrastructure to connect React components with the application's backend logic and data sources.6 Frontend code, written using either JavaScript or TypeScript, typically resides within the src/client or feature-specific subdirectories under src/features.18

On the backend, Node.js provides the runtime environment for executing server-side logic.1 The implementation of WASP Queries and Actions, which handle data fetching and manipulation, is written in Node.js and is typically located in the src/server directory, often organized within subdirectories corresponding to different features of the application.6

For managing the application's database, WASP integrates with Prisma, a modern Object-Relational Mapper (ORM).1 The structure of the database, including tables and their relationships, is defined in the schema.prisma file using Prisma Schema Language (PSL).7 WASP leverages Prisma to generate a type-safe database client, which can be used in the backend Node.js code to perform operations such as creating, reading, updating, and deleting records. This Prisma client is made accessible within the implementations of Queries and Actions through the context.entities object.20

Styling the user interface in the OpenSaaS WASP boilerplate is primarily done using TailwindCSS, a utility-first CSS framework.1 Tailwind provides a set of low-level utility classes that can be directly applied to HTML elements within React components, allowing for rapid styling without the need to write custom CSS in many cases.9 The configuration for TailwindCSS, where developers can customize the framework's behavior, is typically found in the tailwind.config.cjs file located at the root of the project.9 The following table summarizes the core technologies and their roles:

| Technology | Role in the Boilerplate | Snippet References |
| :---- | :---- | :---- |
| React | Frontend UI Library | 1 |
| Node.js | Backend Runtime Environment | 1 |
| Prisma | ORM for Database Interaction | 1 |
| TailwindCSS | Utility-First CSS Framework | 1 |

## **6\. Frontend, Backend, and Database Interaction within the WASP Framework**

The WASP framework simplifies the interaction between the frontend, backend, and database through its concept of Operations, which include Queries for data retrieval and Actions for data manipulation.1 Frontend React components communicate with the backend Node.js logic by invoking these WASP Operations. Queries, declared in the main.wasp file and implemented as Node.js functions in the src/server directory, are used to fetch data from the backend.7 WASP automatically generates a client-side hook called useQuery that React components can use to call these backend functions.16 Notably, WASP handles automatic cache invalidation for Queries, ensuring that the frontend always has the most up-to-date data.7 Actions, also declared in main.wasp and implemented in src/server, are used to perform operations that modify data on the backend, such as creating, updating, or deleting records.7 WASP generates client-side functions for Actions that can be called directly from React components using standard async/await syntax.16 The framework transparently handles the serialization and deserialization of data exchanged between the client and the server for both Queries and Actions.32

On the client-side, WASP leverages React Query, a powerful library for asynchronous data fetching and state management.7 The useQuery hook, generated by WASP for each declared Query, seamlessly integrates with React Query to manage the entire data fetching lifecycle, including handling loading states and potential errors within React components.16 By utilizing this hook, developers can efficiently fetch and cache data from the backend with minimal configuration, taking advantage of React Query's features like background updates and automatic refetching.

The backend logic for both Queries and Actions is implemented as asynchronous Node.js functions located within the src/server directory, often organized by feature.6 These functions receive a context object, which is provided by WASP and contains essential information such as the currently authenticated user's details and access to the application's database Entities through the context.entities property.16 The context.entities object provides access to the type-safe Prisma client, which is then used to interact with the underlying PostgreSQL database to perform the necessary data operations.9 This structured approach ensures a clear separation of concerns, with frontend components focused on rendering the UI and interacting with backend Operations, while the backend logic handles data access and manipulation using Prisma.

## **7\. Code Quality Guidelines and Error Handling in WASP**

WASP, by its design, encourages the development of clean and maintainable code through its structured architecture and the management of boilerplate.6 The strong recommendation and support for TypeScript within the framework further contribute to code quality by enabling type safety and reducing the occurrence of runtime errors.1 The convention of organizing code by features into dedicated directories and adhering to consistent naming conventions for files and variables also plays a significant role in improving code readability and maintainability.18 In projects like vibe-coding-video, there is an explicit emphasis on documenting features within the ai/docs/ directory, highlighting the importance of clear and up-to-date documentation for code understanding and collaboration.25 These practices collectively contribute to a higher standard of code quality in WASP-based applications.

For handling errors within WASP applications, the framework provides specific strategies for both backend and frontend code. In backend Operations (Queries and Actions), for expected error scenarios such as unauthorized access or invalid input, WASP recommends throwing an instance of HttpError from the wasp/server module.20 This allows developers to send structured error responses back to the client, including an HTTP status code, a descriptive message, and optionally, additional error data.32 For unexpected errors that might occur on the server, it is considered a best practice to log these errors for debugging and monitoring purposes.20 On the frontend, when using the useQuery hook to fetch data, the hook returns an error object that can be checked to determine if an error occurred during the data fetching process.16 This error object can then be used to display an appropriate error message to the user. When calling Actions from the frontend, standard try...catch blocks should be used to handle any errors that might be thrown by the backend operation.16 This comprehensive approach to error handling ensures that applications built with WASP are more resilient and provide a better user experience by gracefully handling both expected and unexpected issues.

## **8\. Testing Recommendations for WASP Applications**

WASP provides robust support for testing React applications through its integration with Vitest, a fast unit test framework that has native support for Vite, the build tool used by WASP.36 The framework includes several helpful testing libraries out of the box, such as @vitest/ui for visualizing test results in a user interface, jsdom which provides a web browser-like environment for running tests in Node.js, and @testing-library/react along with @testing-library/jest-dom, which offer utilities for writing effective and user-centric React component tests.36 To ensure that WASP recognizes test files, they should be placed within the src directory of the project and should use filename extensions that match specific glob patterns, such as .test.ts or .spec.jsx.36 Developers can run their tests using the command wasp test client, which starts Vitest in watch mode, automatically re-running tests whenever changes are made to the code. For a one-time execution of all tests, the command wasp test client run can be used.36 Additionally, by appending the \--ui flag to the wasp test client command, a real-time user interface for Vitest is launched, providing a visual overview of the test results.36 To further facilitate React component testing, WASP offers utility functions like renderInContext, which renders a React component wrapped in necessary providers such as QueryClientProvider and Router, and mockServer, which sets up a mock server environment and provides utilities like mockQuery and mockApi for mocking backend Queries and APIs respectively.36 These tools enable developers to write comprehensive tests for their frontend code, ensuring its reliability and correctness. While the provided documentation primarily focuses on frontend testing, standard Node.js testing frameworks like Jest or Mocha can be employed for testing backend logic within the src/server directory.

## **9\. Actionable Guidelines for an AI Coding Agent**

Based on the comprehensive overview of the OpenSaaS WASP boilerplate, here are actionable guidelines for an AI coding agent to follow when generating or modifying code:

* **File Naming and Directory Structure:** When creating new source code files, the AI should use the .ts or .tsx extension, reflecting the strong preference for TypeScript within the WASP ecosystem. Code should be logically organized within the src/ directory by feature, with each feature residing in its own subdirectory (e.g., auth, users, products). Implementations for WASP Operations (Queries and Actions) should be placed in a file named operations.ts within the corresponding feature directory. React components should be located in src/client or feature-specific subdirectories under src/features, and reusable UI components should be placed in src/components.  
* **main.wasp Configuration:** The AI should declare all essential aspects of the application in the main.wasp file. This includes app-level settings, URL routes and their associated pages, authentication configurations, database Entities, Queries for data fetching, Actions for data manipulation, any background Jobs, and custom APIs. When referencing custom code (like component implementations or operation functions) within main.wasp, the AI must always use the @src/ prefix for import paths. For each Query or Action, the AI should ensure that all database Entities used in its implementation are explicitly listed in the entities: \[...\] declaration. To maintain organization, the AI should group related declarations in main.wasp by feature using //\#region {FeatureName} and //\#endregion comments.  
* **Code Formatting and Styling:** The AI should adhere to standard JavaScript and TypeScript code formatting conventions to ensure readability. For frontend styling, the AI should utilize TailwindCSS utility classes directly within React components, following the utility-first approach of the framework.  
* **Backend Logic Implementation:** When implementing backend logic for data retrieval, the AI should create Query functions within the operations.ts files. These functions should use the context.entities object to access the Prisma client and interact with the database. For implementing backend logic for data manipulation, the AI should create Action functions within the same operations.ts files, similarly using context.entities. For handling expected errors in backend Operations, the AI should throw an HttpError from the wasp/server module, including an appropriate HTTP status code and a descriptive message.  
* **Frontend Logic Implementation:** In React components, the AI should use the useQuery hook (generated by WASP) to fetch data from backend Queries, ensuring that it handles the loading and error states appropriately. To perform data mutations on the backend, the AI should call Action functions directly using async/await and should implement error handling using try...catch blocks.  
* **Testing:** The AI should generate unit and component tests for React components using the Vitest framework. Test files should be placed in the src directory with appropriate extensions (e.g., .test.tsx). The AI should use the renderInContext function to render React components in a testing environment and should utilize mockServer along with its utilities (mockQuery, mockApi) to mock backend interactions when testing frontend components in isolation. For backend testing, the AI can use standard Node.js testing frameworks like Jest or Mocha to test the implementations of Queries and Actions.

## **Conclusions**

The OpenSaaS WASP boilerplate provides a powerful and efficient foundation for building modern SaaS applications. By leveraging the full-stack capabilities of the WASP framework, it abstracts away much of the common boilerplate, allowing developers and AI coding agents to focus on the unique business logic of their applications. The central role of the main.wasp configuration file, combined with the code generation process of the WASP compiler, offers a streamlined approach to defining and building web applications. The integration of key technologies like React, Node.js, Prisma, and TailwindCSS provides a modern and robust development stack. Adhering to the established coding conventions, best practices, and testing recommendations is crucial for maintaining a high-quality codebase. For an AI coding agent, understanding the structure of main.wasp, the feature-based organization of the src/ directory, the use of TypeScript, and the mechanisms for frontend-backend interaction through WASP Operations are essential for generating aligned and effective code within this environment.

#### **Works cited**

1. Introduction | OpenSaaS.sh, accessed May 3, 2025, [https://docs.opensaas.sh/](https://docs.opensaas.sh/)  
2. Starter Templates \- Wasp, accessed May 3, 2025, [https://wasp.sh/docs/project/starter-templates](https://wasp.sh/docs/project/starter-templates)  
3. Open SaaS: our free, open-source SaaS starter \- Wasp, accessed May 3, 2025, [https://wasp.sh/blog/2024/01/30/open-saas-free-open-source-starter-react-nodejs](https://wasp.sh/blog/2024/01/30/open-saas-free-open-source-starter-react-nodejs)  
4. From 0 to 400+ Customers: SaaS Growth Hacks from a Serial Founder | OpenSaaS.sh, accessed May 3, 2025, [https://docs.opensaas.sh/blog/2025-01-30-from-0-to-400-customers-saas-growth-hacks/](https://docs.opensaas.sh/blog/2025-01-30-from-0-to-400-customers-saas-growth-hacks/)  
5. sideproject | OpenSaaS.sh, accessed May 3, 2025, [https://docs.opensaas.sh/blog/tags/sideproject/](https://docs.opensaas.sh/blog/tags/sideproject/)  
6. Our open-source SaaS boilerplate starter for React & Node.js just crossed 10,000 stars on GitHub : r/webdev \- Reddit, accessed May 3, 2025, [https://www.reddit.com/r/webdev/comments/1kducr0/our\_opensource\_saas\_boilerplate\_starter\_for\_react/](https://www.reddit.com/r/webdev/comments/1kducr0/our_opensource_saas_boilerplate_starter_for_react/)  
7. Wasp framework, accessed May 3, 2025, [https://wasp.sh/](https://wasp.sh/)  
8. wasp-lang/wasp: The fastest way to develop full-stack web apps with React & Node.js., accessed May 3, 2025, [https://github.com/wasp-lang/wasp](https://github.com/wasp-lang/wasp)  
9. Guided Tour | OpenSaaS.sh, accessed May 3, 2025, [https://docs.opensaas.sh/start/guided-tour/](https://docs.opensaas.sh/start/guided-tour/)  
10. From 0 to 10K : How Open SaaS became the Free Boilerplate Devs Love, accessed May 3, 2025, [https://dev.to/wasp/from-0-to-10k-how-open-saas-became-the-free-boilerplate-devs-love-45hb](https://dev.to/wasp/from-0-to-10k-how-open-saas-became-the-free-boilerplate-devs-love-45hb)  
11. 2\. Project Structure \- Wasp, accessed May 3, 2025, [https://wasp.sh/docs/tutorial/project-structure](https://wasp.sh/docs/tutorial/project-structure)  
12. 2\. Project Structure \- Wasp, accessed May 3, 2025, [https://wasp.sh/docs/0.12.0/tutorial/project-structure](https://wasp.sh/docs/0.12.0/tutorial/project-structure)  
13. User Overview | OpenSaaS.sh, accessed May 3, 2025, [https://docs.opensaas.sh/general/user-overview/](https://docs.opensaas.sh/general/user-overview/)  
14. A dive into Wasp; a domain-specific language for building full stack web applications, accessed May 3, 2025, [https://blog.openreplay.com/a-dive-into-wasp/](https://blog.openreplay.com/a-dive-into-wasp/)  
15. Building an app to find an excuse for our sloppy work \- WASP-LANG.Dev, accessed May 3, 2025, [https://wasp-lang.dev/blog/2022/09/05/dev-excuses-app-tutrial](https://wasp-lang.dev/blog/2022/09/05/dev-excuses-app-tutrial)  
16. 6\. Modifying Data \- Wasp framework, accessed May 3, 2025, [https://wasp-lang.dev/docs/tutorial/actions](https://wasp-lang.dev/docs/tutorial/actions)  
17. Admin Dashboard | OpenSaaS.sh \- Open SaaS Docs, accessed May 3, 2025, [https://docs.opensaas.sh/general/admin-dashboard/](https://docs.opensaas.sh/general/admin-dashboard/)  
18. mathewlewallen/Ready-To-Deploy-SaaS-Template: A production-ready, fully customizable SaaS template using Wasp, React, and Node.js. Includes authentication, payments, and deployment-ready configurations. | Support me: https://buymeacoffee.com/mathewlewallen \- GitHub, accessed May 3, 2025, [https://github.com/mathewlewallen/Ready-To-Deploy-SaaS-Template](https://github.com/mathewlewallen/Ready-To-Deploy-SaaS-Template)  
19. vibe-coding-video/.cursor/rules/1-wasp-overview.mdc at video-starter · wasp-lang/vibe-coding-video · GitHub, accessed May 3, 2025, [https://github.com/wasp-lang/vibe-coding-video/blob/video-starter/.cursor/rules/1-wasp-overview.mdc](https://github.com/wasp-lang/vibe-coding-video/blob/video-starter/.cursor/rules/1-wasp-overview.mdc)  
20. vibe-coding-video/.cursor/rules/3-database-operations.mdc at video-starter · wasp-lang/vibe-coding-video · GitHub, accessed May 3, 2025, [https://github.com/wasp-lang/vibe-coding-video/blob/video-starter/.cursor/rules/3-database-operations.mdc](https://github.com/wasp-lang/vibe-coding-video/blob/video-starter/.cursor/rules/3-database-operations.mdc)  
21. Getting Started | OpenSaaS.sh, accessed May 3, 2025, [https://docs.opensaas.sh/start/getting-started/](https://docs.opensaas.sh/start/getting-started/)  
22. Wasp \- language for developing full-stack Javascript web apps with no boilerplate, accessed May 3, 2025, [https://dev.to/wasp/wasp-language-for-developing-full-stack-javascript-web-apps-with-no-boilerplate-2fo4](https://dev.to/wasp/wasp-language-for-developing-full-stack-javascript-web-apps-with-no-boilerplate-2fo4)  
23. Leveraging Wasp for full-stack development \- LogRocket Blog, accessed May 3, 2025, [https://blog.logrocket.com/leveraging-wasp-full-stack-development/](https://blog.logrocket.com/leveraging-wasp-full-stack-development/)  
24. wasp-lang/vibe-coding-video: Vibe Coding Full-stack App ... \- GitHub, accessed May 3, 2025, [https://github.com/wasp-lang/vibe-coding-video](https://github.com/wasp-lang/vibe-coding-video)  
25. vibe-coding-video/.cursor/rules/2-project-conventions.mdc at video-starter · wasp-lang/vibe-coding-video · GitHub, accessed May 3, 2025, [https://github.com/wasp-lang/vibe-coding-video/blob/video-starter/.cursor/rules/2-project-conventions.mdc](https://github.com/wasp-lang/vibe-coding-video/blob/video-starter/.cursor/rules/2-project-conventions.mdc)  
26. vibe-coding-video/.gitignore at video-starter \- GitHub, accessed May 3, 2025, [https://github.com/wasp-lang/vibe-coding-video/blob/video-starter/.gitignore](https://github.com/wasp-lang/vibe-coding-video/blob/video-starter/.gitignore)  
27. Introduction to Wasp: A DSL for Building Full-Stack Web Applications \- Semaphore, accessed May 3, 2025, [https://semaphoreci.com/blog/wasp-dsl](https://semaphoreci.com/blog/wasp-dsl)  
28. TypeScript Support \- Wasp framework, accessed May 3, 2025, [https://wasp-lang.dev/docs/general/typescript](https://wasp-lang.dev/docs/general/typescript)  
29. tailwind.config.cjs \- wasp-lang/vibe-coding-video \- GitHub, accessed May 3, 2025, [https://github.com/wasp-lang/vibe-coding-video/blob/video-starter/tailwind.config.cjs](https://github.com/wasp-lang/vibe-coding-video/blob/video-starter/tailwind.config.cjs)  
30. Introduction | Wasp, accessed May 3, 2025, [https://wasp-lang.dev/docs/0.14.0](https://wasp-lang.dev/docs/0.14.0)  
31. Queries \- Wasp, accessed May 3, 2025, [https://wasp.sh/docs/0.11.8/data-model/operations/queries](https://wasp.sh/docs/0.11.8/data-model/operations/queries)  
32. Actions \- Wasp, accessed May 3, 2025, [https://wasp-lang.dev/docs/0.13.0/data-model/operations/actions](https://wasp-lang.dev/docs/0.13.0/data-model/operations/actions)  
33. Queries \- WASP-LANG.Dev, accessed May 3, 2025, [https://wasp-lang.dev/docs/data-model/operations/queries](https://wasp-lang.dev/docs/data-model/operations/queries)  
34. Introduction \- Wasp, accessed May 3, 2025, [https://wasp.sh/docs](https://wasp.sh/docs)  
35. Using Wasp to Build Full-Stack Web Applications on Koyeb, accessed May 3, 2025, [https://www.koyeb.com/tutorials/using-wasp-to-build-full-stack-web-applications-on-koyeb](https://www.koyeb.com/tutorials/using-wasp-to-build-full-stack-web-applications-on-koyeb)  
36. Testing \- Wasp, accessed May 3, 2025, [https://wasp.sh/docs/project/testing](https://wasp.sh/docs/project/testing)